import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "../auth/[...nextauth]/route";
import mongoose from "mongoose";
import { User } from "../../lib/model/schema";
import { PDFDocument, rgb, StandardFonts } from "pdf-lib";
import { connectionSRT } from "../../lib/db";

export async function GET() {
  try {
    // 1Ô∏è‚É£ AUTH
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2Ô∏è‚É£ DB CONNECT
    if (mongoose.connection.readyState === 0) {
      await mongoose.connect(connectionSRT);
    }

    // 3Ô∏è‚É£ FETCH USER
    const user = await User.findOne({ email: session.user.email }).lean();
    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const kundali = user.kundaliSnapshots?.[0];
    if (!kundali) {
      return NextResponse.json({ error: "No kundali found" }, { status: 404 });
    }

    // üõ°Ô∏è SAFE TEXT
    const safeText = (v) => {
      if (v === undefined || v === null) return "";
      if (typeof v === "string") return v;
      return JSON.stringify(v);
    };

    // 4Ô∏è‚É£ CREATE PDF
    const pdfDoc = await PDFDocument.create();
    let page = pdfDoc.addPage([595, 1000]); // taller page
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);

    let y = 960;

    // ‚úçÔ∏è BASIC DRAW
    const draw = (text = "", size = 12, spacing = 8) => {
      const content = safeText(text);

      if (y < 80) {
        page = pdfDoc.addPage([595, 1000]);
        y = 960;
      }

      if (!content) {
        y -= spacing;
        return;
      }

      page.drawText(content, {
        x: 40,
        y,
        size,
        font,
        color: rgb(0, 0, 0),
        maxWidth: 515,
        lineHeight: size + 6,
      });

      y -= size + spacing;
    };

    // üß† PARAGRAPH-AWARE DRAW (KEY FIX)
    const drawParagraph = (text, size = 12) => {
      const content = safeText(text);
      if (!content) return;

      const approxCharsPerLine = Math.floor(515 / (size * 0.6));
      const lines = Math.ceil(content.length / approxCharsPerLine);

      draw(content, size, 6);
      y -= lines * (size + 4);
    };

    // üß± SECTION
    const section = (title) => {
      draw("");
      draw(title, 16, 12);
      draw("--------------------------------", 10, 14);
    };

    // 5Ô∏è‚É£ CONTENT
    draw("KUNDALIX ‚Äî VEDIC KUNDALI REPORT", 22, 16);
    draw("Generated by Kundalix AI", 10, 20);

    section("BIRTH DETAILS");
    draw(`Name: ${safeText(user.name)}`);
    draw(`Date of Birth: ${safeText(user.dob)}`);
    draw(`Time of Birth: ${safeText(user.tob)}`);
    draw(`Place of Birth: ${safeText(user.place)}`);

    section("BASIC PROFILE");
    draw(`Sun Sign: ${safeText(kundali.basicProfile?.sunSign)}`);
    draw(`Moon Sign: ${safeText(kundali.basicProfile?.moonSign)}`);
    draw(`Ascendant: ${safeText(kundali.basicProfile?.ascendant)}`);
    draw(`Nakshatra: ${safeText(kundali.basicProfile?.nakshatra)}`);
    draw(`Ruling Planet: ${safeText(kundali.basicProfile?.rulingPlanet)}`);

    section("LIFE DOMAINS");
    Object.entries(kundali.lifeDomains || {}).forEach(([key, value]) => {
      draw(`${key.toUpperCase()}:`, 14, 8);
      drawParagraph(value, 12);
      draw("");
    });

    section("PLANETARY POSITIONS");
    Object.entries(kundali.planetaryPositions || {}).forEach(
      ([planet, data]) => {
        draw(
          `${planet.toUpperCase()}: ${safeText(
            data?.sign
          )} ¬∑ House ${safeText(data?.house)}`,
          13,
          6
        );
        drawParagraph(data?.traits, 12);
        draw("");
      }
    );

    section("YOGAS");
    (kundali.yogas || []).forEach((yoga) => {
      draw(`${safeText(yoga?.name)}:`, 14, 6);
      drawParagraph(yoga?.meaning, 12);
      draw("");
    });

    section("GUIDANCE");
    draw("Strengths:", 14, 6);
    (kundali.guidance?.strengths || []).forEach((s) =>
      draw(`‚Ä¢ ${safeText(s)}`, 12, 4)
    );

    draw("");
    draw("Challenges:", 14, 6);
    (kundali.guidance?.challenges || []).forEach((c) =>
      draw(`‚Ä¢ ${safeText(c)}`, 12, 4)
    );

    draw("");
    draw("Advice:", 14, 6);
    drawParagraph(kundali.guidance?.advice, 12);

    // 6Ô∏è‚É£ FINALIZE
    const pdfBytes = await pdfDoc.save();

    return new NextResponse(Buffer.from(pdfBytes), {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": "attachment; filename=kundali.pdf",
      },
    });
  } catch (err) {
    console.error("PDF ERROR:", err);
    return NextResponse.json(
      { error: "PDF generation failed" },
      { status: 500 }
    );
  }
}
